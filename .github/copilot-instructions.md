# Copilot Instructions — FanPulse

## Architecture

This repo contains three independent applications that implement the **Model Context Protocol (MCP)**:

- **`FanPulse/`** — MCP Server (C# / .NET 10). Exposes 7 fan-engagement tools. Supports **stdio** (default) and **HTTP** (`--http` flag, port 5001) transports. Returns JSON text responses.
- **`FanPulseApps/`** — MCP Server (TypeScript / Node.js). Reimplements the same 7 tools with **interactive HTML UIs** using the MCP Apps extension (`@modelcontextprotocol/ext-apps`). Supports both **stdio and HTTP** (port 3001) transports. Five tools include rich UIs (segment cards, product grid, engagement chart, recommendation cards, promo builder form); two return JSON.
- **`FanPulseDashboard/`** — MCP Apps Host (React + TypeScript). Connects to **both** servers over HTTP simultaneously, adds an AI-powered conversational layer using **GitHub Models (GPT-4o)**. Implements `AppBridge` from the ext-apps SDK for native rendering of interactive UIs.

Data flows: **Browser (React) → Vite proxy → MCP Servers (HTTP) → SQLite (`fanpulse.db`)**  
LLM flow: **Browser → Vite proxy (`/api/chat`) → GitHub Models (GPT-4o)**

Both servers share the same `fanpulse.db` database. The C# server creates and seeds it on first run.

## Build & Run

```powershell
# Build the C# MCP server
dotnet build FanPulse

# Build the TypeScript MCP server
cd FanPulseApps && npm install && npm run build && cd ..

# Install Dashboard dependencies
cd FanPulseDashboard && npm install && cd ..

# Start C# MCP server in HTTP mode (Terminal 1)
dotnet run --project FanPulse -- --http

# Start TypeScript MCP server in HTTP mode (Terminal 2)
cd FanPulseApps && npm start

# Start React Dashboard (Terminal 3)
cd FanPulseDashboard
$env:GITHUB_TOKEN = "ghp_..."
npm run dev
```

There are no tests, linters, or CI pipelines configured.

## Key Conventions

### MCP Tool Definitions (C# Server)

Tools are static methods on a single class annotated with `[McpServerToolType]`:

```csharp
[McpServerToolType]
public class FanTools
{
    [McpServerTool, Description("...")]
    public static string ToolName([Description("...")] string param) { ... }
}
```

Tools are registered in `Program.cs` via `.WithTools<FanTools>()`. The server supports dual transport: stdio (default) via `WithStdioServerTransport()` and HTTP via `WithHttpTransport()` + `MapMcp()` (selected by `--http` flag).

### MCP Tool Definitions (TypeScript Server)

Tools with UIs use `registerAppTool` and `registerAppResource` from `@modelcontextprotocol/ext-apps/server`. Tools without UIs use `server.tool()` directly. Input schemas are defined with Zod. All tools are registered in `src/tools/fan-tools.ts` and wired up in `server.ts` via a `createServer()` factory function.

### Data Access

- **C# Server**: Raw ADO.NET with `Microsoft.Data.Sqlite` — no Entity Framework.
- **TypeScript Server**: `better-sqlite3` with prepared statements.

Both access the same `fanpulse.db`, auto-created and seeded on C# server startup by `DatabaseInitializer.Initialize()`. Schema uses five tables: `Fans`, `EngagementEvents`, `Merchandise`, `Purchases`, `Promotions`.

### ID Patterns

Entity IDs follow a consistent format: `fan-001`, `prod-001`, `evt-001`, `pur-001`, `promo-{guid}`. New IDs for events and promotions are generated by truncating a GUID.

### Dashboard Architecture (React)

The Dashboard is a React + TypeScript + Vite app that acts as a proper MCP Apps host:

- Connects to both MCP servers over HTTP via `StreamableHTTPClientTransport`
- Uses `AppBridge` + `PostMessageTransport` from `@modelcontextprotocol/ext-apps/app-bridge` to render interactive UIs in sandboxed iframes (`allow-scripts allow-same-origin allow-forms`)
- AppBridge constructor receives the MCP client, host capabilities (`serverTools`, `serverResources` from server caps), and initial `hostContext` (theme, CSS custom properties with `--` prefix, container dimensions)
- Bridge auto-proxies `callServerTool()` from UIs back to the MCP server; HTML is injected via `document.write()` after the bridge transport starts listening
- LLM calls are proxied through a Vite dev server plugin (`/api/chat`) to keep `GITHUB_TOKEN` server-side
- MCP requests are proxied through Vite: `/api/fanpulse` → port 5001, `/api/fanpulseapps` → port 3001
- Chat runs sequentially (C# server first, then Apps server) to avoid GitHub Models rate limits

Key files:
- `src/components/App.tsx` — Main layout + chat orchestration
- `src/components/AppFrame.tsx` — ext-apps iframe + AppBridge lifecycle
- `src/hooks/useMcpClient.ts` — React hook for MCP connections
- `src/hooks/chatService.ts` — LLM function-calling loop
- `vite.config.ts` — Proxy config + LLM middleware plugin

### UI Bundling (TypeScript Server)

Each UI is a standalone HTML file in `src/ui/<tool-name>/`. Vite + `vite-plugin-singlefile` bundles each into a self-contained HTML string (inline CSS/JS) in `dist/`. The server serves these as `ui://` resources with `text/html+mcp` MIME type.

## Dependencies

| Package | Used In | Purpose |
|---|---|---|
| `ModelContextProtocol` (0.8.0-preview.1) | FanPulse | MCP server SDK (C#) |
| `ModelContextProtocol.AspNetCore` (0.8.0-preview.1) | FanPulse | HTTP transport for C# MCP server |
| `Microsoft.Data.Sqlite` | FanPulse | SQLite data access (C#) |
| `@modelcontextprotocol/sdk` | FanPulseApps, Dashboard | MCP server/client SDK (TypeScript) |
| `@modelcontextprotocol/ext-apps` | FanPulseApps, Dashboard | MCP Apps extension — server-side tools and client-side AppBridge |
| `better-sqlite3` | FanPulseApps | SQLite data access (TypeScript) |
| `chart.js` | FanPulseApps | Engagement metrics chart rendering |
| `vite` + `vite-plugin-singlefile` | FanPulseApps | Bundle UIs into single HTML files |
| `react` + `react-dom` | Dashboard | UI framework |
| `openai` | Dashboard | OpenAI-compatible chat types |
